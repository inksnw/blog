<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rusts on </title>
    <link>http://localhost:1313/rust/</link>
    <description>Recent content in Rusts on </description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 29 Nov 2022 11:51:30 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>15.作用域规则</title>
      <link>http://localhost:1313/rust/15.%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/</link>
      <pubDate>Fri, 07 Oct 2022 22:01:48 +0800</pubDate>
      <guid>http://localhost:1313/rust/15.%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;作用域在所有权（ownership）、借用（borrow）和生命周期（lifetime）中起着重要作用。也就是说，作用域告诉编译器什么时候借用是合法的、什么时候资源可以释放、以及变量何时被创建或销毁。&lt;/p&gt;</description>
    </item>
    <item>
      <title>14.泛型</title>
      <link>http://localhost:1313/rust/14.%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Thu, 06 Oct 2022 17:12:49 +0800</pubDate>
      <guid>http://localhost:1313/rust/14.%E6%B3%9B%E5%9E%8B/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;泛型&lt;/strong&gt;（generic）是关于泛化类型和函数功能，以扩大其适用范围的话题。泛型极大地 减少了代码的重复，但它自身的语法很要求细心。也就是说，采用泛型意味着仔细地指定 泛型类型具体化时，什么样的具体类型是合法的。泛型最简单和常用的用法是用于类型参数。&lt;/p&gt;</description>
    </item>
    <item>
      <title>13.属性</title>
      <link>http://localhost:1313/rust/13.%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Thu, 06 Oct 2022 17:05:02 +0800</pubDate>
      <guid>http://localhost:1313/rust/13.%E5%B1%9E%E6%80%A7/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;属性是应用于某些模块、crate 或项的元数据（metadata）。这元数据可以用来：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/attribute/cfg.html&#34;&gt;条件编译代码&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/attribute/crate.html&#34;&gt;设置 crate 名称、版本和类型（二进制文件或库）&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;禁用 &lt;a href=&#34;https://en.wikipedia.org/wiki/Lint_(software)&#34;&gt;lint&lt;/a&gt; （警告）&lt;/li&gt;&#xA;&lt;li&gt;启用编译器的特性（宏、全局导入（glob import）等）&lt;/li&gt;&#xA;&lt;li&gt;链接到一个非 Rust 语言的库&lt;/li&gt;&#xA;&lt;li&gt;标记函数作为单元测试&lt;/li&gt;&#xA;&lt;li&gt;标记函数作为基准测试的某个部分&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;当属性作用于整个 crate 时，它们的语法为 &lt;code&gt;#![crate_attribute]&lt;/code&gt;，当它们用于模块 或项时，语法为 &lt;code&gt;#[item_attribute]&lt;/code&gt;（注意少了感叹号 &lt;code&gt;!&lt;/code&gt;）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>12.cargo</title>
      <link>http://localhost:1313/rust/12.cargo/</link>
      <pubDate>Thu, 06 Oct 2022 12:46:57 +0800</pubDate>
      <guid>http://localhost:1313/rust/12.cargo/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;依赖&#34;&gt;依赖&lt;/h2&gt;&#xA;&lt;p&gt;大多数程序都会依赖于某些库。如果你曾经手动管理过库依赖，那么你就知道这会带来的极大的痛苦。幸运的是，Rust 的生态链标配 &lt;code&gt;cargo&lt;/code&gt; 工具！&lt;code&gt;cargo&lt;/code&gt; 可以管理项目的依赖关系。&lt;/p&gt;</description>
    </item>
    <item>
      <title>11.crate</title>
      <link>http://localhost:1313/rust/11.crate/</link>
      <pubDate>Sun, 02 Oct 2022 22:07:11 +0800</pubDate>
      <guid>http://localhost:1313/rust/11.crate/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Crate&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;crate（中文有 “包，包装箱” 之意）是 Rust 的编译单元。当调用 &lt;code&gt;rustc some_file.rs&lt;/code&gt; 时，&lt;code&gt;some_file.rs&lt;/code&gt; 被当作 &lt;strong&gt;crate 文件&lt;/strong&gt;。如果 &lt;code&gt;some_file.rs&lt;/code&gt; 里面含有 &lt;code&gt;mod&lt;/code&gt; 声明，那么模块文件的内容将在编译之前被插入 crate 文件的相应声明处。换句话说，模 块&lt;strong&gt;不会&lt;/strong&gt;单独被编译，只有 crate 才会被编译。&lt;/p&gt;</description>
    </item>
    <item>
      <title>10.模块</title>
      <link>http://localhost:1313/rust/10.%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 02 Oct 2022 20:34:37 +0800</pubDate>
      <guid>http://localhost:1313/rust/10.%E6%A8%A1%E5%9D%97/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;模块&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Rust 提供了一套强大的模块（module）系统，可以将代码按层次分成多个逻辑 单元（模块），并管理这些模块之间的可见性（公有（public）或私有（private））。&lt;/p&gt;</description>
    </item>
    <item>
      <title>9.函数</title>
      <link>http://localhost:1313/rust/9.%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 02 Oct 2022 17:19:01 +0800</pubDate>
      <guid>http://localhost:1313/rust/9.%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;函数（function）使用 &lt;code&gt;fn&lt;/code&gt; 关键字来声明。函数的参数需要标注类型，就和变量一样，如果函数返回一个值，返回类型必须在箭头 &lt;code&gt;-&amp;gt;&lt;/code&gt; 之后指定。&lt;/p&gt;&#xA;&lt;p&gt;函数最后的表达式将作为返回值。也可以在函数内使用 &lt;code&gt;return&lt;/code&gt; 语句来提前返一个值，甚至可以在循环或 &lt;code&gt;if&lt;/code&gt; 内部使用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>8.流程控制</title>
      <link>http://localhost:1313/rust/8.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Thu, 29 Sep 2022 01:02:22 +0800</pubDate>
      <guid>http://localhost:1313/rust/8.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;ifelse&#34;&gt;if/else&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;if-else&lt;/code&gt;分支判断和其它语言类似.不同的是,Rust语言中的布尔判断不必使用小括号包裹,且每个条件后面都跟着一个代码块.&lt;code&gt;if-else&lt;/code&gt;条件是一个表达式,并且所有分支都必须返回相同的类型.&lt;/p&gt;</description>
    </item>
    <item>
      <title>7.表达式</title>
      <link>http://localhost:1313/rust/7.%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Thu, 29 Sep 2022 00:52:09 +0800</pubDate>
      <guid>http://localhost:1313/rust/7.%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Rust 程序（大部分）由一系列语句构成：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 语句&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 语句&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 语句&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;Rust 有多种语句。最普遍的语句类型有两种：一种是声明绑定变量，另一种是表达式带上英文分号(;)：&lt;/p&gt;</description>
    </item>
    <item>
      <title>6.类型转换</title>
      <link>http://localhost:1313/rust/6.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Wed, 28 Sep 2022 20:22:07 +0800</pubDate>
      <guid>http://localhost:1313/rust/6.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;类型转换&#34;&gt;类型转换&lt;/h2&gt;&#xA;&lt;p&gt;Rust使用&lt;code&gt;trait&lt;/code&gt;解决类型之间的转换问题.一般的转换会用到&lt;code&gt;From&lt;/code&gt;和&lt;code&gt;Into&lt;/code&gt;两个trait.不过,即便常见的情况也可能会用到特别的trait,尤其是从&lt;code&gt;String&lt;/code&gt;转换到别的类型,以及把的类型转换到&lt;code&gt;String&lt;/code&gt;时.&lt;/p&gt;</description>
    </item>
    <item>
      <title>5.类型系统</title>
      <link>http://localhost:1313/rust/5.%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 22 Sep 2022 23:29:19 +0800</pubDate>
      <guid>http://localhost:1313/rust/5.%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Rust 提供了多种机制，用于改变或定义原生类型和用户定义类型。接下来会讲到：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;原生类型的类型转换 (cast)&lt;/li&gt;&#xA;&lt;li&gt;指定字面量的类型&lt;/li&gt;&#xA;&lt;li&gt;使用类型推断 (type inference)&lt;/li&gt;&#xA;&lt;li&gt;类型别名&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;类型转换&#34;&gt;类型转换&lt;/h1&gt;&#xA;&lt;p&gt;Rust 不提供原生类型之间的隐式类型转换 (coercion),但可以使用&lt;code&gt;as&lt;/code&gt;关键字进行显式类型转换 (casting)&lt;/p&gt;</description>
    </item>
    <item>
      <title>4.变量绑定</title>
      <link>http://localhost:1313/rust/4.%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Thu, 22 Sep 2022 10:43:25 +0800</pubDate>
      <guid>http://localhost:1313/rust/4.%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Rust 通过静态类型确保类型安全。变量绑定可以在声明时说明类型，不过在多数情况下， 编译器能够从上下文推导出变量的类型，从而大大减少了类型说明的工作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>3.自定义类型</title>
      <link>http://localhost:1313/rust/3.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 21 Sep 2022 23:23:20 +0800</pubDate>
      <guid>http://localhost:1313/rust/3.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Rust自定义数据类型主要通过下面两个关键字创建:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;struct&lt;/code&gt;: 定义一个结构体&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;enum&lt;/code&gt;: 定义一个枚举类型&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;而常量 (constant) 可以通过 &lt;code&gt;const&lt;/code&gt; 和&lt;code&gt;static&lt;/code&gt;关键字来创建.&lt;/p&gt;&#xA;&lt;h1 id=&#34;结构体&#34;&gt;结构体&lt;/h1&gt;&#xA;&lt;p&gt;结构体有3种类型,使用&lt;code&gt;struct&lt;/code&gt;关键字来创建:&lt;/p&gt;</description>
    </item>
    <item>
      <title>2.原生类型</title>
      <link>http://localhost:1313/rust/2.%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 21 Sep 2022 21:27:12 +0800</pubDate>
      <guid>http://localhost:1313/rust/2.%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;字面量和运算符&#34;&gt;字面量和运算符&lt;/h1&gt;&#xA;&lt;p&gt;整数&lt;code&gt;1&lt;/code&gt;,浮点数&lt;code&gt;1.2&lt;/code&gt;,字符&lt;code&gt;a&lt;/code&gt;,字符串&lt;code&gt;abc&lt;/code&gt;,布尔值&lt;code&gt;true&lt;/code&gt;和单元类型&lt;code&gt;()&lt;/code&gt;可以用数字,文字或符号之类的&amp;quot;字面量&amp;quot;(literal)来表示.&lt;/p&gt;</description>
    </item>
    <item>
      <title>1.Hello World</title>
      <link>http://localhost:1313/rust/1.hello-world/</link>
      <pubDate>Tue, 20 Sep 2022 22:01:13 +0800</pubDate>
      <guid>http://localhost:1313/rust/1.hello-world/</guid>
      <description>&lt;p&gt;手敲一遍 &lt;a href=&#34;https://rustwiki.org/zh-CN/rust-by-example/index.html&#34;&gt;通过例子学Rust&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;格式化输出&#34;&gt;格式化输出&lt;/h1&gt;&#xA;&lt;h2 id=&#34;调试debug&#34;&gt;调试(Debug)&lt;/h2&gt;&#xA;&lt;p&gt;所有的类型,若想使用 &lt;code&gt;std::fmt&lt;/code&gt; 的格式化打印,都要求实现至少一个可打印的&lt;code&gt;traits&lt;/code&gt;.仅有一些类型提供了自动实现,比如&lt;code&gt;std&lt;/code&gt;库中的类型.其它类型都必须手动实现.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rust学习:包与泛型</title>
      <link>http://localhost:1313/rust/rust%E5%AD%A6%E4%B9%A0%E5%8C%85%E4%B8%8E%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Fri, 09 Sep 2022 15:39:58 +0800</pubDate>
      <guid>http://localhost:1313/rust/rust%E5%AD%A6%E4%B9%A0%E5%8C%85%E4%B8%8E%E6%B3%9B%E5%9E%8B/</guid>
      <description>&lt;h2 id=&#34;包crate和模块&#34;&gt;包、Crate和模块&lt;/h2&gt;&#xA;&lt;p&gt;rust的模块系统包括:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;包: cargo的一个功能，它允许你构建、测试、分享crate。一个包可以包含多个二进制crate和一个可选的库crate&lt;/li&gt;&#xA;&lt;li&gt;crate: 一个模块的树形结构，它形成了库或二进制项目&lt;/li&gt;&#xA;&lt;li&gt;模块(mod)和&lt;code&gt;use&lt;/code&gt;: 模块通过use来使用，允许你控制作用域和路径的私有性&lt;/li&gt;&#xA;&lt;li&gt;路径(path): 一个命名例如结构体、函数或模块等项的方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;包和crate&#34;&gt;包和crate&lt;/h3&gt;&#xA;&lt;p&gt;crate是一个二进制项或库。 &lt;code&gt;crate root&lt;/code&gt;是一个源文件，crate 是一个二进制项或者库。Rust 编译器以&lt;code&gt;crate root&lt;/code&gt;为起始点，构成你的 crate 的根模块。 crate将一个作用域相关的功能分组到一起，使得这些功能可以方便的在多个项目间共享。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rust学习:所有权与结构体</title>
      <link>http://localhost:1313/rust/rust%E5%AD%A6%E4%B9%A0%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Fri, 09 Sep 2022 00:12:03 +0800</pubDate>
      <guid>http://localhost:1313/rust/rust%E5%AD%A6%E4%B9%A0%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>&lt;h2 id=&#34;所有权&#34;&gt;所有权&lt;/h2&gt;&#xA;&lt;h3 id=&#34;栈与堆&#34;&gt;栈与堆&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 &lt;strong&gt;后进先出&lt;/strong&gt;（&lt;em&gt;last in, first out&lt;/em&gt;）。增加数据叫做 &lt;strong&gt;进栈&lt;/strong&gt;（&lt;em&gt;pushing onto the stack&lt;/em&gt;），而移出数据叫做 &lt;strong&gt;出栈&lt;/strong&gt;（&lt;em&gt;popping off the stack&lt;/em&gt;）。栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 &lt;strong&gt;指针&lt;/strong&gt;（&lt;em&gt;pointer&lt;/em&gt;）。这个过程称作 &lt;strong&gt;在堆上分配内存&lt;/strong&gt;（&lt;em&gt;allocating on the heap&lt;/em&gt;），有时简称为 “分配”（allocating）。（将数据推入栈中并不被认为是分配）。因为指向放入堆中数据的指针是已知的并且大小是固定的，你可以将该指针存储在栈上，不过当需要实际数据时，必须访问指针。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
