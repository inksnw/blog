Searching 484 files for "src="http://inksnw.asuscomm.com:3001/blog"

~/Desktop/blog/content/life/2021一点记录.md:
    7  这个总结写于22年5月,一直拖着要搞个博客,终于是搭起来了.
    8  
    9: ​			<img src="http://inksnw.asuscomm.com:3001/blog/iShot_2022-05-26_21.30.38.jpg" alt="iShot_2022-05-26_21.30.38" style="zoom: 67%;" />
   10  

~/Desktop/blog/content/life/关于2023.md:
    9  初雪落薄衫，赤胆压天寒。破虏八百万，洒酒祭长安。
   10  
   11: <img src="http://inksnw.asuscomm.com:3001/blog/关于2023_bf9c2ed3abc9a69e27c18dca601b6b15.jpeg" alt="v2-4096cedd5634d9851f72c41bd7dc2292_r" style="zoom:67%;" />
   12  
   13  ## 二
   ..
   15  初来人间不知苦，潦草半生一身无。转身回望来时路，才知生时为何哭
   16  
   17:  <img src="http://inksnw.asuscomm.com:3001/blog/关于2023_ed2a4fc534950bbc43ce15063f66c471.png" alt="image-20240220224748122" style="zoom:67%;" />
   18  

~/Desktop/blog/content/life/往前走,不要回头.md:
    5  ---
    6  
    7: <img src="http://inksnw.asuscomm.com:3001/blog/往前走,不要回头_bbe2fd51b3c57733a6880061e361441c.webp" alt="p2998296" style="zoom:60%;" />
    8  

~/Desktop/blog/content/life/该怎么跟你描述这种感觉.md:
    9  
   10  <video width="720" height="415" autoplay="autoplay" controls>
   11: <source src="http://inksnw.asuscomm.com:3001/blog/该怎么跟你描述这种感觉.mp4" type="video/mp4">
   12  </video>
   13  

~/Desktop/blog/content/post/cert-manager使用.md:
    9  cert-manager 部署到 Kubernetes 集群后，它会 watch 它所支持的 CRD 资源，我们通过创建 CRD 资源来指示 cert-manager 为我们签发证书并自动续期:
   10  
   11: <img src="http://inksnw.asuscomm.com:3001/blog/cert-manager使用_f2fe5a87ab3ea068935705e6a1fd7435.png" alt="image-20220923141435361" style="zoom: 50%;" />
   12  
   13  几个关键的资源:
   ..
  105  
  106  
  107: <img src="http://inksnw.asuscomm.com:3001/blog/cert-manager使用_02876af27e28815da1fe18fde7a98d13.png" alt="ssl-wrong-version" style="zoom:50%;" />
  108  
  109  找了半天原因,尝试使用curl访问
  ...
  124  再次访问
  125  
  126: <img src="http://inksnw.asuscomm.com:3001/blog/cert-manager使用_8dace1259dbbac20a873dcfcf8cab671.png" alt="image-20220923172433508" style="zoom:50%;" />
  127  
  128  chrome没有`继续前往`的解决办法,在当前页,键盘盲输`thisisunsafe`

~/Desktop/blog/content/post/cilium初探.md:
  111  ```
  112  
  113: <img src="http://inksnw.asuscomm.com:3001/blog/cilium初探_95fc20d1b4f6747a098d6361cd489828.png" alt="image-20231204232622229" style="zoom:50%;" />
  114  

~/Desktop/blog/content/post/docker+flannel跨主机通信.md:
   76  此时 `etcd` 中也会出现这台主机的信息, 这个图形管理工具是 `etcdkeeper`
   77  
   78: <img src="http://inksnw.asuscomm.com:3001/blog/docker+flannel跨主机通信_6103c187ed1c704b3452b66f9bcef685.png" alt="image-20221124195408776" style="zoom:50%;" />
   79  
   80  

~/Desktop/blog/content/post/ebpf.md:
  194  ## XDP 拦截 ICMP 协议
  195  
  196: <img src="http://inksnw.asuscomm.com:3001/blog/ebpf_79a9c2792be062eb095fa7e0146a80cf.webp" alt="Untitled.png" style="zoom: 40%;" />
  197  
  198  xdp_md 在头文件 /usr/include/linux/bpf.h 有定义：

~/Desktop/blog/content/post/etcd简单使用.md:
   73  发生变化时会通过grpc主动推送事件
   74  
   75: <img src="http://inksnw.asuscomm.com:3001/blog/etcd简单使用_072628a3341b0dab6f443ce2f003c0ca.png" alt="image-20221105194741685" style="zoom:50%;" />
   76  
   77  ```go

~/Desktop/blog/content/post/fluent-bit日志收集.md:
  135  查询
  136  
  137: <img src="http://inksnw.asuscomm.com:3001/blog/fluent-bit日志收集_1539f772172be7ccf3a9f07e30b0579d.png" alt="image-20220928002559025" style="zoom:50%;" />
  138  
  139  ## input配置

~/Desktop/blog/content/post/grpc示例.md:
   70  ## grpc-gateway
   71  
   72: <img src="http://inksnw.asuscomm.com:3001/blog/grpc示例_5874e0789443312fbfaba72906001c9d.png" alt="grpc-gateway" style="zoom: 50%;" />
   73  
   74  当 HTTP 请求到达 gRPC-Gateway 时，它将 JSON 数据解析为 Protobuf 消息。然后，它使用解析的 Protobuf 消息发出正常的 Go gRPC 客户端请求。Go gRPC 客户端将 Protobuf 结构编码为 Protobuf 二进制格式，然后将其发送到 gRPC 服务器。gRPC 服务器处理请求并以 Protobuf 二进制格式返回响应。Go gRPC 客户端将其解析为 Protobuf 消息，并将其返回到 gRPC-Gateway，后者将 Protobuf 消息编码为 JSON 并将其返回给原始客户端。

~/Desktop/blog/content/post/harbor安装与containerd.md:
   94  >  用户名,密码明明是对的,却登录不上,显示密码错误,折腾了好久,docker都重装了也没用,开`F12`看到返回消息 `CSRF Token Invalid`,查到 [issue](https://github.com/goharbor/harbor/issues/12676) 清空chrome Storage即可
   95  
   96: <img src="http://inksnw.asuscomm.com:3001/blog/harbor安装与containerd_64fda2673e4bbf152a1fc84a80e9e8a6.png" alt="134382902-03254048-8a2b-4847-9504-1d2b9bfb239d" style="zoom:50%;" />
   97  
   98  ## 配置containerd
   ..
  145  上传成功
  146  
  147: <img src="http://inksnw.asuscomm.com:3001/blog/harbor安装与containerd_83b2069f2073684f82111d6ae6285f0e.png" alt="image-20220930173345991" style="zoom:50%;" />
  148  
  149  ### 批量上传

~/Desktop/blog/content/post/k8s删除crd会发生什么.md:
   60  可以看到crd存储于`/registry/apiextensions.k8s.io/customresourcedefinitions/crontabs.stable.example.com`
   61  
   62: <img src="http://inksnw.asuscomm.com:3001/blog/k8s删除crd会发生什么_2ce0d3a45a47e6ce641edf35623906e8.png" alt="image-20230629141221544" style="zoom:67%;" />
   63  
   64  cr存储于`/registry/stable.example.com/crontabs/default/my-new-cron-object`
   65  
   66: <img src="http://inksnw.asuscomm.com:3001/blog/k8s删除crd会发生什么_1d72f5c14a77fb775722bd1ebaf74c0d.png" alt="image-20230629141321816" style="zoom:67%;" />
   67  
   68  ### 删除crd
   ..
  138  这里再查看etcd中的数据, crd已经消失, cr还存储于etcd中, 这个情况k8s会如何处理这个数据, 不知道会不会永久成为垃圾数据
  139  
  140: <img src="http://inksnw.asuscomm.com:3001/blog/k8s删除crd会发生什么_dbf2638650507e005821955a15a7a1cf.png" alt="image-20230629143450608" style="zoom:67%;" />
  141  
  142  再次创建回crd, 这个cr 居然还可以再次查到, 好吧, 看来crd与cr之间并无特定惟一标识对应

~/Desktop/blog/content/post/k8s运行流程追踪.md:
   85  ```
   86  
   87: <img src="http://inksnw.asuscomm.com:3001/blog/k8s运行流程追踪_08e48e93a114b7d2efda4c3eb128ddda.png" alt="image-20230915135617342" style="zoom:67%;" />
   88  
   89  此时 jaeger 的界面上已可以看到运行的流程, 对jaeger 的ui不太熟悉, 没有找出一个很好的示例, 由于是开发者自己决定在代码的哪些位置添加追踪点, 可能并不能满足使用者都对追踪的需求, 可以试下字节跳动开源的 Kelemetry

~/Desktop/blog/content/post/k8s配置gpu.md:
  193  进入如下网址 https://catalog.ngc.nvidia.com/orgs/nim/teams/meta/containers/llama3-8b-instruct, 点击右上角的 `get container`, 填写信息后, 会收到邮件,再次查看此页面就可以看到镜像版本了,
  194  
  195: <img src="http://inksnw.asuscomm.com:3001/blog/k8s配置gpu_副本_811f8eab270e84eb1d54aa8c204e0662.png" alt="企业微信截图_76efa6ae-25da-402b-aa91-953a73ebe112" style="zoom:50%;" />
  196  
  197  收到允许邮件后, 再次查看tag如图, 此时生成的ncg api key才能拉取镜像, 否则会报权限问题
  198  
  199: <img src="http://inksnw.asuscomm.com:3001/blog/k8s配置gpu_副本_28b41536d7a1d9b403c23069effd2dca.png" alt="image-20240606100402704" style="zoom:50%;" />
  200  
  201  进入 https://org.ngc.nvidia.com/setup  申请key
  202  
  203: <img src="http://inksnw.asuscomm.com:3001/blog/k8s配置gpu_副本_613a7870f03e15455bbcacc0e62cbda2.png" alt="image-20240606100527318" style="zoom:50%;" />
  204  
  205  ### 安装

~/Desktop/blog/content/post/kubelet证书过期分析.md:
   31  ```
   32  
   33: <img src="http://inksnw.asuscomm.com:3001/blog/kubelet证书过期分析_d3eb52476fd77144ec910bb59ef5af10.png" alt="image-20231203110835717" style="zoom:50%;" />
   34  
   35  kubelet启动时, 检测`isClientConfigStillValid` 旧证书失败, 去寻找 bootstrap 文件也不存在, 于是报错

~/Desktop/blog/content/post/Kubernetes中拉取带凭证的容器镜像.md:
   19  
   20  kubelet启动的时候会读取 `searchPaths` 中的配置文件
   21: <img src="http://inksnw.asuscomm.com:3001/blog/Kubernetes中拉取带凭证的容器镜像_35eee10da3d183008a977cff24752a25.png" alt="image-20230922140925408" style="zoom:50%;" />
   22  
   23  实际获取凭据的时候会把 `imagePullSecrets` 的信息和kubelet启动文件拿到的信息合并
   24  
   25: <img src="http://inksnw.asuscomm.com:3001/blog/Kubernetes中拉取带凭证的容器镜像_00a60edd332da84e96262bb2f6f00a76.png" alt="image-20230922141216159" style="zoom:50%;" />
   26  
   27  查看运行日志
   ..
   39  源码位于`kubernetes-1.26.5/pkg/kubelet/kubelet.go` 1827行, 在syncPod的步骤中会发送grpc的拉取镜像请求, 这时会使用带上的认证信息, 这个信息来自于pod的 `imagePullSecrets`
   40  
   41: <img src="http://inksnw.asuscomm.com:3001/blog/Kubernetes中拉取带凭证的容器镜像_9b829e648e5360c9a165c4b5f6f58034.png" alt="image-20230830210358808" style="zoom:50%;" />
   42  
   43  简单使用, 手动注入

~/Desktop/blog/content/post/nginx-ingress.md:
   26  - Local表示：流量只发给本机的Pod。
   27  
   28: <img src="http://inksnw.asuscomm.com:3001/blog/nginx-ingress_ad0022e96a73a6a8d7fb41c6b6f0c1ff.png" alt="image-20220922222116679" style="zoom: 50%;" />
   29  
   30  ### Cluster
   ..
   48  同时，由于本机不会跨节点转发报文，所以要想所有节点上的容器有负载均衡，就需要上一级的Loadbalancer来做了。
   49  
   50: <img src="http://inksnw.asuscomm.com:3001/blog/nginx-ingress_efba8c2e767b0cf86f72a7ace17c97ea.png" alt="1464583-20200707174845450-1319538618" style="zoom:50%;" />
   51  
   52  不过流量还是会不太均衡，如上图，Loadbalancer看到的是2个后端（把节点的IP），每个Node上面几个Pod对Loadbalancer来说是不知道的。
   ..
  109  发现其实本质就是配置了nginx的域名转发
  110  
  111: <img src="http://inksnw.asuscomm.com:3001/blog/nginx-ingress_bdc7364de5da8c2f4e185ea3e55ef455.png" alt="image-20220922213751633" style="zoom:50%;" />
  112  
  113  ## 配置https
  ...
  238  访问测试
  239  
  240: <img src="http://inksnw.asuscomm.com:3001/blog/nginx-ingress_08c782a6666c57fcfb6e01c47b1d8fe3.png" alt="image-20230527123409161" style="zoom:50%;" />
  241  
  242  
  ...
  278  ```
  279  
  280: <img src="http://inksnw.asuscomm.com:3001/blog/nginx-ingress_8202422854fee1e25162af095b4e22ef.jpg" alt="Snipaste_2022-09-23_10-26-22" style="zoom:50%;" />
  281  
  282  ## 限流设置

~/Desktop/blog/content/post/OpenTelemetry使用.md:
   64  ```
   65  
   66: <img src="http://inksnw.asuscomm.com:3001/blog/OpenTelemetry使用_d3a6255352cf09dee377af017c56e4cd.png" alt="image-20220925182452720" style="zoom:50%;" />
   67  

~/Desktop/blog/content/post/pod原地升级.md:
   23  核心逻辑都在`kubernetes-1.26.5/pkg/kubelet/kuberuntime/kuberuntime_manager.go` 的 **678** 行 `func (m *kubeGenericRuntimeManager) SyncPod(...)` 中, 在一开始会检测`func PodSandboxChanged(pod *v1.Pod, podStatus *kubecontainer.PodStatus) (bool, uint32, string)` 
   24  
   25: <img src="http://inksnw.asuscomm.com:3001/blog/pod原地升级_c957f90c907a280f9b9a2666154c5796.png" alt="image-20230918153847126" style="zoom:50%;" />
   26  
   27  可以看到有几点判断条件,
   ..
   41  那这个数组的数据是如何加入的, 在625 行看到, 当 `containerChanged(&container, containerStatus)` 为真时, 即会被加入
   42  
   43: <img src="http://inksnw.asuscomm.com:3001/blog/pod原地升级_571dfacd2ee32a7d3f0f03d2983b3111.png" alt="image-20230918155019412" style="zoom:50%;" />
   44  
   45  继续看`containerChanged`的逻辑, 这时就比较简单了

~/Desktop/blog/content/post/prometheus.md:
  220  一个业务pod通过exporter生成metrics svc,再由ServiceMonitor通过标签和port名筛选找到,operator会把这个信息转化成相应的prometheus配置文件
  221  
  222: <img src="http://inksnw.asuscomm.com:3001/blog/prometheus_e8a23cc25c96c0bc0f620b7f48fd4208.png" alt="prometheus-architecture" style="zoom: 33%;" />
  223  
  224  ```yaml

~/Desktop/blog/content/post/runc.md:
    7  runc 是一个命令行客户端，用于运行根据 Open Container Initiative (OCI) 格式打包的应用程序
    8  
    9: <img src="http://inksnw.asuscomm.com:3001/blog/runc_cb5954ad2c7242b97e5cf81611d377b5.png" alt="2021-01-27_cri-containerd2" style="zoom: 50%;" />
   10  
   11  上图是k8s调用`containerd`到拉起pod进程的流程,拉起pod这个过程是由调用二进制的`runc`完成的,拉起后`runc`退出,不作为常驻进程
   ..
  163  容器网络基本原理
  164  
  165: <img src="http://inksnw.asuscomm.com:3001/blog/runc_582804a69ecbeb334c544888b2521d08.png" alt="rancher_blog_image12-1" style="zoom: 67%;" />
  166  
  167  创建网桥

~/Desktop/blog/content/post/Tekton和argocd使用.md:
  100  查看图形界面
  101  
  102: <img src="http://inksnw.asuscomm.com:3001/blog/Tekton和argocd使用_0e87c8f1eecf273adae9217db1ba60e8.png" alt="image-20220924211406813" style="zoom: 50%;" />
  103  
  104  我们可以通过 `kubectl describe` 命令来查看任务运行的过程，当任务执行完成后， Pod 就会变成 `Completed` 状态了：

~/Desktop/blog/content/post/vxlan使用.md:
   11  ## 点对点模式
   12  
   13: <img src="http://inksnw.asuscomm.com:3001/blog/vxlan使用_55abc651d2676d86057d5a780c071c3c.jpg" alt="vxlan" style="zoom:50%;" />
   14  
   15  在逻辑上形成的VXLAN overlay网络环境如上图，虚线部分示意出来的Overlay Network和VXLAN Tunnel都是逻辑上的概念。容器不用感知底层物理网络，看起来对端是和自己在同一个二层环境里，就是像是在VTEP设备的上面直接构建了一条VXLAN Tunnel，把Overlay网络里的网络接口直接在二层打通。
   ..
   81  导入`wireshark`查看
   82  
   83: <img src="http://inksnw.asuscomm.com:3001/blog/vxlan使用_5886c9b8455b9de8ee387a511d7029e4.png" alt="Snipaste_2022-11-27_22-16-24" style="zoom:50%;" />
   84  
   85  ## 广播模式
   ..
  178  此时的网络拓扑
  179  
  180: <img src="http://inksnw.asuscomm.com:3001/blog/vxlan使用_e3661f8f12dff2de75b4b064fa116bce.jpg" alt="vxlan docker" style="zoom:50%;" />
  181  
  182  有了VXLAN接口的连接后，从vm1上docker容器发出的包到达docker网桥后，可以从网桥的VXLAN接口出去，从而报文在VETP(VXLAN接口)处被封装成VXLAN报文，再从物理网络上到达对端VETP所在的主机vm2。对端VTEP能正确解包VXLAN报文的话，随后即可将报文通过vm2上的docker网桥送到上层的docker容器中。

~/Desktop/blog/content/post/webhook影响k8s全局gc.md:
   66  查看kube-controller的日志会发现
   67  
   68: <img src="http://inksnw.asuscomm.com:3001/blog/webhook影响k8s全局gc_7716fbb60d4999a9a203c277c9d34364.png" alt="image-20231121155432905" style="zoom:50%;" />
   69  
   70  ## 原因追踪
   ..
   74  gc会收集所有可删除的资源列表生成 `newResources`
   75  
   76: <img src="http://inksnw.asuscomm.com:3001/blog/webhook影响k8s全局gc_d3f59a700dbbb28410a9f431edd093a3.png" alt="image-20231121154832747" style="zoom:50%;" />
   77  
   78  为所有可删除的资源创建informer
   79  
   80: <img src="http://inksnw.asuscomm.com:3001/blog/webhook影响k8s全局gc_58e3285164444b1947f774b7d938d89f.png" alt="image-20231121155058272" style="zoom:50%;" />
   81  
   82  核心原因就在这里
   83  
   84: <img src="http://inksnw.asuscomm.com:3001/blog/webhook影响k8s全局gc_999ae8cda743b50757b01fe654de56a6.png" alt="image-20231121155142767" style="zoom:50%;" />
   85  
   86  k8s要求所有可删除的资源的informer都同步完成才行, 而informer会调用list方法, 但是由于我们的crd使用的webhook还未安装/运行错误, 因此这个同步一直无法完成, 所以也影响到了其它资源的gc, 感觉这块的实现并不是很合理

~/Desktop/blog/content/post/使用Charles抓取k8s请求.md:
    9  安装`Charles`,查看设置`Proxy->Proxy Settings`,Charles默认监听于8888端口
   10  
   11: <img src="http://inksnw.asuscomm.com:3001/blog/使用Charles抓取k8s请求_b8c69aac5fddbb8c2d0ecc23c47d32bf.png" alt="image-20230523172630419" style="zoom:50%;" />
   12  
   13  ## 配置客户端证书
   ..
   26  配置Charles，`Proxy->SSL Proxying Settings`让他拦截端口为`6443`的流量：
   27  
   28: <img src="http://inksnw.asuscomm.com:3001/blog/使用Charles抓取k8s请求_cc7636d20e3cb6e5130b86d2bc28f4c2.png" alt="image-20230523173343158" style="zoom:50%;" />
   29  
   30  然后配置客户端私钥：
   31  
   32: <img src="http://inksnw.asuscomm.com:3001/blog/使用Charles抓取k8s请求_950c76b038342426129a372040e59f01.png" alt="image-20230523171636777" style="zoom:50%;" />
   33  
   34  
   ..
   40  配置
   41  
   42: <img src="http://inksnw.asuscomm.com:3001/blog/使用Charles抓取k8s请求_742ae7fa188feb655d5b21b7489e05f9.png" alt="image-20230523171952403" style="zoom:50%;" />
   43  
   44  ## 配置kubectl

~/Desktop/blog/content/post/使用github作为Helm的chart仓库.md:
   62  ## 设置GitHub Pages
   63  
   64: <img src="http://inksnw.asuscomm.com:3001/blog/使用github作为Helm的chart仓库_4702eb9bb1298308ea430cd67a2d0c70.png" alt="image-20220927172720598" style="zoom:50%;" />
   65  
   66  > 设置`_config.yml`文件可以配置主题, 可选

~/Desktop/blog/content/post/使用goland远程开发.md:
   39  - 在右上角的编辑配置打开以下配置菜单
   40  - 把原本的`本地机器` 改过通过`管理目标`添加的远程主机,可以指定源码和二进制的目录
   41: <img src="http://inksnw.asuscomm.com:3001/blog/使用goland远程开发_2b21e985d3f722bd34ae811ca0368f1c.png" alt="image-20221113235729865" style="zoom:50%;" />
   42  
   43  - 注意勾选上 **在远程目标上构建**, 否则还是会在本地编译
   44  
   45: <img src="http://inksnw.asuscomm.com:3001/blog/使用goland远程开发_69d0a34c9a4223cda14f14fee4582c7e.png" alt="image-20221113235449156" style="zoom:50%;" />
   46  
   47  ## 验证

~/Desktop/blog/content/post/使用pyroscope追查资源占用.md:
   95  在界面上切换要监听的程序
   96  
   97: <img src="http://inksnw.asuscomm.com:3001/blog/使用pyroscope追查资源占用_9395294a94cc66a18cef093a6a139588.png" alt="image-20230703180710548" style="zoom:50%;" />
   98  
   99  ### 选项解释
  ...
  111  可以看到`main.highCpu` 函数最占cpu
  112  
  113: <img src="http://inksnw.asuscomm.com:3001/blog/使用pyroscope追查资源占用_dd9b2a28a44745ee0ffe77238e5d2800.png" alt="image-20230703181135182" style="zoom: 67%;" />
  114  
  115  ## 内存占用
  ...
  117  `main.highMem` 最占用内存
  118  
  119: <img src="http://inksnw.asuscomm.com:3001/blog/使用pyroscope追查资源占用_4e1c8c1d85e5130a7958e50193fa9b4a.png" alt="image-20230703181252627" style="zoom: 67%;" />
  120  

~/Desktop/blog/content/post/使用rust编写envoy扩展.md:
   79  envoy配置结构
   80  
   81: <img src="http://inksnw.asuscomm.com:3001/blog/使用rust编写envoy扩展_1310473275110bfc967ed40c84d75284.png" alt="20200504160047" style="zoom: 50%;" />
   82  
   83  

~/Desktop/blog/content/post/升级带controller的crd.md:
  163  ## 源码分析
  164  
  165: <img src="http://inksnw.asuscomm.com:3001/blog/升级带controller的crd_9d09e21d90b2a27de40389b5034a2499.png" alt="image-20231211185944756" style="zoom:50%;" />
  166  
  167  当`served` 为false时, 就会跳过写入`addAPIServiceToSync`
  ...
  185  `addAPIServiceToSync` 会把数据写入到一个队列中, 这个队列会被取出注册api服务
  186  
  187: <img src="http://inksnw.asuscomm.com:3001/blog/升级带controller的crd_75d369b81273b20a7e88b9e0c24170f4.png" alt="image-20231211190244071" style="zoom:50%;" />
  188  
  189  如同这个字段的注释, api 服务关了, controller自然也就不运行了

~/Desktop/blog/content/post/在k8s外部验证bearertoken.md:
  106  可以使用https://jwt.io/ 查看token信息
  107  
  108: <img src="http://inksnw.asuscomm.com:3001/blog/在k8s外部验证bearertoken_1181bba4e34083cb460bdb2ca83f3edf.png" alt="image-20230713003203964" style="zoom:50%;" />
  109  
  110  ## 使用token
  ...
  183  ## 访问测试
  184  
  185: <img src="http://inksnw.asuscomm.com:3001/blog/在k8s外部验证bearertoken_8f74306191085e6a05e64be98e760823.png" alt="image-20230713000337476" style="zoom: 50%;" />
  186  

~/Desktop/blog/content/post/容器技术原理-OCI规范.md:
  121  解压查看,可以看到第二层只有一个app目录,与我们的`Dockerfile`配置一致
  122  
  123: <img src="http://inksnw.asuscomm.com:3001/blog/容器技术原理-OCI规范_2eef73d14d6af274763c853300f0a7e1.png" alt="image-20221128213021570" style="zoom:50%;" />
  124  
  125  ## umoci制作镜像

~/Desktop/blog/content/post/本地签发证书代理https.md:
  171  ```
  172  
  173: <img src="http://inksnw.asuscomm.com:3001/blog/本地签发证书代理https_c2e63853f1d7b3601b4581e4fd824f59.png" alt="image-20240410103958436" style="zoom:50%;" />
  174  
  175  此时,证书不受信任
  ...
  177  双击ca.crt加入到系统信任中
  178  
  179: <img src="http://inksnw.asuscomm.com:3001/blog/本地签发证书代理https_79584d3e26dfab47d53144b237082679.png" alt="image-20240410104731767" style="zoom:50%;" />
  180  
  181  再次访问
  182  
  183: <img src="http://inksnw.asuscomm.com:3001/blog/本地签发证书代理https_879c2a3bf8d89a98fba411408abce9c5.png" alt="image-20240410104818353" style="zoom:50%;" />
  184  
  185  

~/Desktop/blog/content/post/本地调试k8s.md:
   78  ```
   79  
   80: <img src="http://inksnw.asuscomm.com:3001/blog/本地调试k8s_2f27f1a6e2a99465d21b16f178efb7b7.png" alt="image-20230802163758775" style="zoom:50%;" />
   81  
   82  kubectl配置

~/Desktop/blog/content/post/查看容器重启前日志.md:
  177  当容器退出时, 会把容器id记录到status的`Terminated`字段中
  178  
  179: <img src="http://inksnw.asuscomm.com:3001/blog/查看容器重启前日志_e6f01abc73d656bfd3c16c086c797391.png" alt="image-20231220225211656" style="zoom:50%;" />
  180  
  181  查看当前pod状态, 看到上次退出的容器id 记录于`status.containerStatuses[0].lastState.terminated.containerID` 中
  ...
  211  当加上`-p` 参数时, 查看日志时使用的容器id就会是上次的id
  212  
  213: <img src="http://inksnw.asuscomm.com:3001/blog/查看容器重启前日志_7f695ed9b3f4f24bd0044323ad860ddb.png" alt="image-20231220225840595" style="zoom:50%;" />
  214  
  215  接着就是通过容器id查看日志的标准流程了

~/Desktop/blog/content/post/模拟k8s的watch.md:
   54  访问测试
   55  
   56: <img src="http://inksnw.asuscomm.com:3001/blog/模拟k8s的watch_f8d0496aea5cb9e794d3e6d3f09fb9d7.png" alt="Snipaste_2023-06-21_23-00-29" style="zoom:50%;" />
   57  

~/Desktop/blog/content/post/自定义日志库实现行号打印及跳转.md:
   47  可以看到终端上已经有了带超链接的行号, 点击可直接跳转
   48  
   49: <img src="http://inksnw.asuscomm.com:3001/blog/自定义日志库实现行号打印及跳转_3c370988be6e601fc6cd627aba15e4d6.png" alt="image-20230814165916930" style="zoom:50%;" />
   50  
   51  ### klog/v2
   ..
   68  ```
   69  
   70: <img src="http://inksnw.asuscomm.com:3001/blog/自定义日志库实现行号打印及跳转_8cce880b82d057990bfae8fe6e649fbd.png" alt="image-20240113224931657" style="zoom:50%;" />
   71  
   72  可以看到已经显示了可跳转的超链接, 调试起来就方便了

~/Desktop/blog/content/post/通过kube-router学习网络.md:
  471  ### pod到pod(同主机)
  472  
  473: <img src="http://inksnw.asuscomm.com:3001/blog/通过kube-router学习网络1_52247654491a5c826a972cfff611648d.png" alt="image-20230728095909030" style="zoom:50%;" />
  474  
  475  创建两个同主机Pod
  ...
  599  ### pod到outside
  600  
  601: <img src="http://inksnw.asuscomm.com:3001/blog/通过kube-router学习网络1_e415d248c4d6991e7217ca5117c3b79a.png" alt="image-20230728105027087" style="zoom:50%;" />
  602  
  603  **查看iptables规则**
  ...
  656  ### outside到svc到pod
  657  
  658: <img src="http://inksnw.asuscomm.com:3001/blog/通过kube-router学习网络1_6ca604634e8c6403b21587d64077648a.png" alt="image-20230728111722176" style="zoom:50%;" />
  659  
  660  **iptables策略**
  ...
  673  ### pod到svc到pod
  674  
  675: <img src="http://inksnw.asuscomm.com:3001/blog/通过kube-router学习网络1_34d789a9a265ed643f9579a7e32f514e.png" alt="image-20230728113136373" style="zoom: 50%;" />
  676  
  677  创建示例

~/Desktop/blog/public/life/2021一点记录/index.html:
  153    <div class="post-content">
  154      <p>这个总结写于22年5月,一直拖着要搞个博客,终于是搭起来了.</p>
  155: <p>​			<img src="http://inksnw.asuscomm.com:3001/blog/iShot_2022-05-26_21.30.38.jpg" alt="iShot_2022-05-26_21.30.38" style="zoom: 67%;" /></p>
  156  
  157    </div>

~/Desktop/blog/public/life/关于2023/index.html:
  160      <h2 id="一">一</h2>
  161  <p>初雪落薄衫，赤胆压天寒。破虏八百万，洒酒祭长安。</p>
  162: <img src="http://inksnw.asuscomm.com:3001/blog/关于2023_bf9c2ed3abc9a69e27c18dca601b6b15.jpeg" alt="v2-4096cedd5634d9851f72c41bd7dc2292_r" style="zoom:67%;" />
  163  <h2 id="二">二</h2>
  164  <p>初来人间不知苦，潦草半生一身无。转身回望来时路，才知生时为何哭</p>
  165:  <img src="http://inksnw.asuscomm.com:3001/blog/关于2023_ed2a4fc534950bbc43ce15063f66c471.png" alt="image-20240220224748122" style="zoom:67%;" />
  166  
  167    </div>

~/Desktop/blog/public/life/往前走不要回头/index.html:
  151    
  152    <div class="post-content">
  153:     <img src="http://inksnw.asuscomm.com:3001/blog/往前走,不要回头_bbe2fd51b3c57733a6880061e361441c.webp" alt="p2998296" style="zoom:60%;" />
  154  
  155    </div>

~/Desktop/blog/public/life/该怎么跟你描述这种感觉/index.html:
  151      <p>下载自 B 站 <a href="https://www.bilibili.com/video/BV1XC411W7TW">https://www.bilibili.com/video/BV1XC411W7TW</a></p>
  152  <video width="720" height="415" autoplay="autoplay" controls>
  153: <source src="http://inksnw.asuscomm.com:3001/blog/该怎么跟你描述这种感觉.mp4" type="video/mp4">
  154  </video>
  155  

~/Desktop/blog/public/post/cert-manager使用/index.html:
  169          <h3 id="cert-manager-工作原理">cert-manager 工作原理</h3>
  170  <p>cert-manager 部署到 Kubernetes 集群后，它会 watch 它所支持的 CRD 资源，我们通过创建 CRD 资源来指示 cert-manager 为我们签发证书并自动续期:</p>
  171: <img src="http://inksnw.asuscomm.com:3001/blog/cert-manager使用_f2fe5a87ab3ea068935705e6a1fd7435.png" alt="image-20220923141435361" style="zoom: 50%;" />
  172  <p>几个关键的资源:</p>
  173  <ul>
  ...
  325  </span></span></code></pre></td></tr></table>
  326  </div>
  327: </div><img src="http://inksnw.asuscomm.com:3001/blog/cert-manager使用_02876af27e28815da1fe18fde7a98d13.png" alt="ssl-wrong-version" style="zoom:50%;" />
  328  <p>找了半天原因,尝试使用curl访问</p>
  329  <div class="highlight"><div class="chroma">
  ...
  351  </div><p>原来32599是http的端口,https需要使用31306</p>
  352  <p>再次访问</p>
  353: <img src="http://inksnw.asuscomm.com:3001/blog/cert-manager使用_8dace1259dbbac20a873dcfcf8cab671.png" alt="image-20220923172433508" style="zoom:50%;" />
  354  <p>chrome没有<code>继续前往</code>的解决办法,在当前页,键盘盲输<code>thisisunsafe</code></p>
  355  

~/Desktop/blog/public/post/cilium初探/index.html:
  358  </span></span></code></pre></td></tr></table>
  359  </div>
  360: </div><img src="http://inksnw.asuscomm.com:3001/blog/cilium初探_95fc20d1b4f6747a098d6361cd489828.png" alt="image-20231204232622229" style="zoom:50%;" />
  361  
  362      </div>

~/Desktop/blog/public/post/docker+flannel跨主机通信/index.html:
  286  </div>
  287  </div><p>此时 <code>etcd</code> 中也会出现这台主机的信息, 这个图形管理工具是 <code>etcdkeeper</code></p>
  288: <img src="http://inksnw.asuscomm.com:3001/blog/docker+flannel跨主机通信_6103c187ed1c704b3452b66f9bcef685.png" alt="image-20221124195408776" style="zoom:50%;" />
  289  <h2 id="修改docker配置">修改docker配置</h2>
  290  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/ebpf/index.html:
  496  </div>
  497  </div><h2 id="xdp-拦截-icmp-协议">XDP 拦截 ICMP 协议</h2>
  498: <img src="http://inksnw.asuscomm.com:3001/blog/ebpf_79a9c2792be062eb095fa7e0146a80cf.webp" alt="Untitled.png" style="zoom: 40%;" />
  499  <p>xdp_md 在头文件 /usr/include/linux/bpf.h 有定义：</p>
  500  <ul>

~/Desktop/blog/public/post/etcd简单使用/index.html:
  278  <p>在 etcd v3 中，为了解决 etcd v2 的以上缺陷，使用的是基于 HTTP/2 的 gRPC 协议，双向流的 Watch API 设计，实现了连接多路复用。</p>
  279  <p>发生变化时会通过grpc主动推送事件</p>
  280: <img src="http://inksnw.asuscomm.com:3001/blog/etcd简单使用_072628a3341b0dab6f443ce2f003c0ca.png" alt="image-20221105194741685" style="zoom:50%;" />
  281  <div class="highlight"><div class="chroma">
  282  <table class="lntable"><tr><td class="lntd">

~/Desktop/blog/public/post/fluent-bit日志收集/index.html:
  368  </div>
  369  </div><p>查询</p>
  370: <img src="http://inksnw.asuscomm.com:3001/blog/fluent-bit日志收集_1539f772172be7ccf3a9f07e30b0579d.png" alt="image-20220928002559025" style="zoom:50%;" />
  371  <h2 id="input配置">input配置</h2>
  372  <p>tail配置,input与output通过<code>Tag</code>与<code>Match</code>字段进行对应</p>

~/Desktop/blog/public/post/grpc示例/index.html:
  274  <p><a href="http://inksnw.asuscomm.com:3000/inksnw/grpc">http://inksnw.asuscomm.com:3000/inksnw/grpc</a></p>
  275  <h2 id="grpc-gateway">grpc-gateway</h2>
  276: <img src="http://inksnw.asuscomm.com:3001/blog/grpc示例_5874e0789443312fbfaba72906001c9d.png" alt="grpc-gateway" style="zoom: 50%;" />
  277  <p>当 HTTP 请求到达 gRPC-Gateway 时，它将 JSON 数据解析为 Protobuf 消息。然后，它使用解析的 Protobuf 消息发出正常的 Go gRPC 客户端请求。Go gRPC 客户端将 Protobuf 结构编码为 Protobuf 二进制格式，然后将其发送到 gRPC 服务器。gRPC 服务器处理请求并以 Protobuf 二进制格式返回响应。Go gRPC 客户端将其解析为 Protobuf 消息，并将其返回到 gRPC-Gateway，后者将 Protobuf 消息编码为 JSON 并将其返回给原始客户端。</p>
  278  <h3 id="安装gateway插件">安装gateway插件</h3>

~/Desktop/blog/public/post/harbor安装与containerd/index.html:
  331  <p>用户名,密码明明是对的,却登录不上,显示密码错误,折腾了好久,docker都重装了也没用,开<code>F12</code>看到返回消息 <code>CSRF Token Invalid</code>,查到 <a href="https://github.com/goharbor/harbor/issues/12676">issue</a> 清空chrome Storage即可</p>
  332  </blockquote>
  333: <img src="http://inksnw.asuscomm.com:3001/blog/harbor安装与containerd_64fda2673e4bbf152a1fc84a80e9e8a6.png" alt="134382902-03254048-8a2b-4847-9504-1d2b9bfb239d" style="zoom:50%;" />
  334  <h2 id="配置containerd">配置containerd</h2>
  335  <p>配置 <code>/etc/containerd/config.toml</code>如下</p>
  ...
  407  </blockquote>
  408  <p>上传成功</p>
  409: <img src="http://inksnw.asuscomm.com:3001/blog/harbor安装与containerd_83b2069f2073684f82111d6ae6285f0e.png" alt="image-20220930173345991" style="zoom:50%;" />
  410  <h3 id="批量上传">批量上传</h3>
  411  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/k8s删除crd会发生什么/index.html:
  253  <p>使用工具<code>https://github.com/inksnw/etcdviewer</code>查看etcd中的信息</p>
  254  <p>可以看到crd存储于<code>/registry/apiextensions.k8s.io/customresourcedefinitions/crontabs.stable.example.com</code></p>
  255: <img src="http://inksnw.asuscomm.com:3001/blog/k8s删除crd会发生什么_2ce0d3a45a47e6ce641edf35623906e8.png" alt="image-20230629141221544" style="zoom:67%;" />
  256  <p>cr存储于<code>/registry/stable.example.com/crontabs/default/my-new-cron-object</code></p>
  257: <img src="http://inksnw.asuscomm.com:3001/blog/k8s删除crd会发生什么_1d72f5c14a77fb775722bd1ebaf74c0d.png" alt="image-20230629141321816" style="zoom:67%;" />
  258  <h3 id="删除crd">删除crd</h3>
  259  <div class="highlight"><div class="chroma">
  ...
  364  </div>
  365  </div><p>这里再查看etcd中的数据, crd已经消失, cr还存储于etcd中, 这个情况k8s会如何处理这个数据, 不知道会不会永久成为垃圾数据</p>
  366: <img src="http://inksnw.asuscomm.com:3001/blog/k8s删除crd会发生什么_dbf2638650507e005821955a15a7a1cf.png" alt="image-20230629143450608" style="zoom:67%;" />
  367  <p>再次创建回crd, 这个cr 居然还可以再次查到, 好吧, 看来crd与cr之间并无特定惟一标识对应</p>
  368  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/k8s运行流程追踪/index.html:
  289  </span></span></code></pre></td></tr></table>
  290  </div>
  291: </div><img src="http://inksnw.asuscomm.com:3001/blog/k8s运行流程追踪_08e48e93a114b7d2efda4c3eb128ddda.png" alt="image-20230915135617342" style="zoom:67%;" />
  292  <p>此时 jaeger 的界面上已可以看到运行的流程, 对jaeger 的ui不太熟悉, 没有找出一个很好的示例, 由于是开发者自己决定在代码的哪些位置添加追踪点, 可能并不能满足使用者都对追踪的需求, 可以试下字节跳动开源的 Kelemetry</p>
  293  <h2 id="kelemetry">Kelemetry</h2>

~/Desktop/blog/public/post/k8s配置gpu/index.html:
  478  <p>nim下的镜像需要单独申请访问权限才能拉取</p>
  479  <p>进入如下网址 <a href="https://catalog.ngc.nvidia.com/orgs/nim/teams/meta/containers/llama3-8b-instruct">https://catalog.ngc.nvidia.com/orgs/nim/teams/meta/containers/llama3-8b-instruct</a>, 点击右上角的 <code>get container</code>, 填写信息后, 会收到邮件,再次查看此页面就可以看到镜像版本了,</p>
  480: <img src="http://inksnw.asuscomm.com:3001/blog/k8s配置gpu_副本_811f8eab270e84eb1d54aa8c204e0662.png" alt="企业微信截图_76efa6ae-25da-402b-aa91-953a73ebe112" style="zoom:50%;" />
  481  <p>收到允许邮件后, 再次查看tag如图, 此时生成的ncg api key才能拉取镜像, 否则会报权限问题</p>
  482: <img src="http://inksnw.asuscomm.com:3001/blog/k8s配置gpu_副本_28b41536d7a1d9b403c23069effd2dca.png" alt="image-20240606100402704" style="zoom:50%;" />
  483  <p>进入 <a href="https://org.ngc.nvidia.com/setup">https://org.ngc.nvidia.com/setup</a>  申请key</p>
  484: <img src="http://inksnw.asuscomm.com:3001/blog/k8s配置gpu_副本_613a7870f03e15455bbcacc0e62cbda2.png" alt="image-20240606100527318" style="zoom:50%;" />
  485  <h3 id="安装">安装</h3>
  486  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/kubelet证书过期分析/index.html:
  189  </span></span></code></pre></td></tr></table>
  190  </div>
  191: </div><img src="http://inksnw.asuscomm.com:3001/blog/kubelet证书过期分析_d3eb52476fd77144ec910bb59ef5af10.png" alt="image-20231203110835717" style="zoom:50%;" />
  192  <p>kubelet启动时, 检测<code>isClientConfigStillValid</code> 旧证书失败, 去寻找 bootstrap 文件也不存在, 于是报错</p>
  193  <p>所以, 两种修复思路</p>

~/Desktop/blog/public/post/kubernetes中拉取带凭证的容器镜像/index.html:
  188  </blockquote>
  189  <p>kubelet启动的时候会读取 <code>searchPaths</code> 中的配置文件
  190: <img src="http://inksnw.asuscomm.com:3001/blog/Kubernetes中拉取带凭证的容器镜像_35eee10da3d183008a977cff24752a25.png" alt="image-20230922140925408" style="zoom:50%;" /></p>
  191  <p>实际获取凭据的时候会把 <code>imagePullSecrets</code> 的信息和kubelet启动文件拿到的信息合并</p>
  192: <img src="http://inksnw.asuscomm.com:3001/blog/Kubernetes中拉取带凭证的容器镜像_00a60edd332da84e96262bb2f6f00a76.png" alt="image-20230922141216159" style="zoom:50%;" />
  193  <p>查看运行日志</p>
  194  <div class="highlight"><div class="chroma">
  ...
  206  </div><h2 id="配置到pod中">配置到pod中</h2>
  207  <p>源码位于<code>kubernetes-1.26.5/pkg/kubelet/kubelet.go</code> 1827行, 在syncPod的步骤中会发送grpc的拉取镜像请求, 这时会使用带上的认证信息, 这个信息来自于pod的 <code>imagePullSecrets</code></p>
  208: <img src="http://inksnw.asuscomm.com:3001/blog/Kubernetes中拉取带凭证的容器镜像_9b829e648e5360c9a165c4b5f6f58034.png" alt="image-20230830210358808" style="zoom:50%;" />
  209  <p>简单使用, 手动注入</p>
  210  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/nginx-ingress/index.html:
  205  </li>
  206  </ul>
  207: <img src="http://inksnw.asuscomm.com:3001/blog/nginx-ingress_ad0022e96a73a6a8d7fb41c6b6f0c1ff.png" alt="image-20220922222116679" style="zoom: 50%;" />
  208  <h3 id="cluster">Cluster</h3>
  209  <p>注：这个是默认模式，Kube-proxy不管容器实例在哪，公平转发。</p>
  ...
  216  <p>注：这种模式下的Service类型只能为外部流量，即：LoadBalancer 或者 NodePort 两种，否则会报错。</p>
  217  <p>同时，由于本机不会跨节点转发报文，所以要想所有节点上的容器有负载均衡，就需要上一级的Loadbalancer来做了。</p>
  218: <img src="http://inksnw.asuscomm.com:3001/blog/nginx-ingress_efba8c2e767b0cf86f72a7ace17c97ea.png" alt="1464583-20200707174845450-1319538618" style="zoom:50%;" />
  219  <p>不过流量还是会不太均衡，如上图，Loadbalancer看到的是2个后端（把节点的IP），每个Node上面几个Pod对Loadbalancer来说是不知道的。</p>
  220  <p>想要解决负载不均衡的问题：可以给Pod容器设置反亲和，让这些容器平均的分布在各个节点上（不要聚在一起）。</p>
  ...
  302  </div>
  303  </div><p>发现其实本质就是配置了nginx的域名转发</p>
  304: <img src="http://inksnw.asuscomm.com:3001/blog/nginx-ingress_bdc7364de5da8c2f4e185ea3e55ef455.png" alt="image-20220922213751633" style="zoom:50%;" />
  305  <h2 id="配置https">配置https</h2>
  306  <p>签发证书 <code>cert.sh</code></p>
  ...
  536  </div>
  537  </div><p>访问测试</p>
  538: <img src="http://inksnw.asuscomm.com:3001/blog/nginx-ingress_08c782a6666c57fcfb6e01c47b1d8fe3.png" alt="image-20230527123409161" style="zoom:50%;" />
  539  <h2 id="baseauth认证">BaseAuth认证</h2>
  540  <p>文档 <a href="https://kubernetes.github.io/ingress-nginx/examples/auth/basic/">https://kubernetes.github.io/ingress-nginx/examples/auth/basic/</a></p>
  ...
  591  </span></span></code></pre></td></tr></table>
  592  </div>
  593: </div><img src="http://inksnw.asuscomm.com:3001/blog/nginx-ingress_8202422854fee1e25162af095b4e22ef.jpg" alt="Snipaste_2022-09-23_10-26-22" style="zoom:50%;" />
  594  <h2 id="限流设置">限流设置</h2>
  595  <p>文档: <a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#rate-limiting">https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#rate-limiting</a></p>

~/Desktop/blog/public/post/opentelemetry使用/index.html:
  234  </span></span></code></pre></td></tr></table>
  235  </div>
  236: </div><img src="http://inksnw.asuscomm.com:3001/blog/OpenTelemetry使用_d3a6255352cf09dee377af017c56e4cd.png" alt="image-20220925182452720" style="zoom:50%;" />
  237  
  238      </div>

~/Desktop/blog/public/post/pod原地升级/index.html:
  175  <p>我们知道, Pod IP 的网络名称空间等都是依附于sandbox容器的, 只要sandbox重建, 这些信息都会重建</p>
  176  <p>核心逻辑都在<code>kubernetes-1.26.5/pkg/kubelet/kuberuntime/kuberuntime_manager.go</code> 的 <strong>678</strong> 行 <code>func (m *kubeGenericRuntimeManager) SyncPod(...)</code> 中, 在一开始会检测<code>func PodSandboxChanged(pod *v1.Pod, podStatus *kubecontainer.PodStatus) (bool, uint32, string)</code></p>
  177: <img src="http://inksnw.asuscomm.com:3001/blog/pod原地升级_c957f90c907a280f9b9a2666154c5796.png" alt="image-20230918153847126" style="zoom:50%;" />
  178  <p>可以看到有几点判断条件,</p>
  179  <ul>
  ...
  187  <p><img src="https://inksnw.asuscomm.com:3001/blog/pod%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7_5fbc7fdb7fd567c756473841aac9584e.png" alt="image-20230918154534223"></p>
  188  <p>那这个数组的数据是如何加入的, 在625 行看到, 当 <code>containerChanged(&amp;container, containerStatus)</code> 为真时, 即会被加入</p>
  189: <img src="http://inksnw.asuscomm.com:3001/blog/pod原地升级_571dfacd2ee32a7d3f0f03d2983b3111.png" alt="image-20230918155019412" style="zoom:50%;" />
  190  <p>继续看<code>containerChanged</code>的逻辑, 这时就比较简单了</p>
  191  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/prometheus/index.html:
  541  <h2 id="创建servicemonitor">创建ServiceMonitor</h2>
  542  <p>一个业务pod通过exporter生成metrics svc,再由ServiceMonitor通过标签和port名筛选找到,operator会把这个信息转化成相应的prometheus配置文件</p>
  543: <img src="http://inksnw.asuscomm.com:3001/blog/prometheus_e8a23cc25c96c0bc0f620b7f48fd4208.png" alt="prometheus-architecture" style="zoom: 33%;" />
  544  <div class="highlight"><div class="chroma">
  545  <table class="lntable"><tr><td class="lntd">

~/Desktop/blog/public/post/runc/index.html:
  167      <div class="post-content">
  168          <p>runc 是一个命令行客户端，用于运行根据 Open Container Initiative (OCI) 格式打包的应用程序</p>
  169: <img src="http://inksnw.asuscomm.com:3001/blog/runc_cb5954ad2c7242b97e5cf81611d377b5.png" alt="2021-01-27_cri-containerd2" style="zoom: 50%;" />
  170  <p>上图是k8s调用<code>containerd</code>到拉起pod进程的流程,拉起pod这个过程是由调用二进制的<code>runc</code>完成的,拉起后<code>runc</code>退出,不作为常驻进程</p>
  171  <p><strong>疑问</strong></p>
  ...
  415  <h2 id="配置容器网络">配置容器网络</h2>
  416  <p>容器网络基本原理</p>
  417: <img src="http://inksnw.asuscomm.com:3001/blog/runc_582804a69ecbeb334c544888b2521d08.png" alt="rancher_blog_image12-1" style="zoom: 67%;" />
  418  <p>创建网桥</p>
  419  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/tekton和argocd使用/index.html:
  305  </div>
  306  </div><p>查看图形界面</p>
  307: <img src="http://inksnw.asuscomm.com:3001/blog/Tekton和argocd使用_0e87c8f1eecf273adae9217db1ba60e8.png" alt="image-20220924211406813" style="zoom: 50%;" />
  308  <p>我们可以通过 <code>kubectl describe</code> 命令来查看任务运行的过程，当任务执行完成后， Pod 就会变成 <code>Completed</code> 状态了：</p>
  309  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/vxlan使用/index.html:
  165  <p>VXLAN是Virtual eXtensible Local Area Network的缩写,是一个在传统Layer 3网络上架设出来的Layer 2 overlay网络</p>
  166  <h2 id="点对点模式">点对点模式</h2>
  167: <img src="http://inksnw.asuscomm.com:3001/blog/vxlan使用_55abc651d2676d86057d5a780c071c3c.jpg" alt="vxlan" style="zoom:50%;" />
  168  <p>在逻辑上形成的VXLAN overlay网络环境如上图，虚线部分示意出来的Overlay Network和VXLAN Tunnel都是逻辑上的概念。容器不用感知底层物理网络，看起来对端是和自己在同一个二层环境里，就是像是在VTEP设备的上面直接构建了一条VXLAN Tunnel，把Overlay网络里的网络接口直接在二层打通。</p>
  169  <p>在IP地址分配后，Linux系统的路由表就会创建一条路由，去往<code>10.0.0.0/24</code>网段的报文走网络接口<code>vxlan0</code>出去。vm1上去往10.0.0.0/24的报文，在<code>vxlan0</code>上会做VXLAN封装，内层地址是<code>10.16.0.3</code>，外层地址是<code>192.168.50.29</code>。VXLAN报文通过物理网络达到对端vm2上的VETP vxlan0做VXLAN协议的解封装，从而结束整个过程。</p>
  ...
  267  </div>
  268  </div><p>导入<code>wireshark</code>查看</p>
  269: <img src="http://inksnw.asuscomm.com:3001/blog/vxlan使用_5886c9b8455b9de8ee387a511d7029e4.png" alt="Snipaste_2022-11-27_22-16-24" style="zoom:50%;" />
  270  <h2 id="广播模式">广播模式</h2>
  271  <p>过arp泛洪来学习mac地址,即在vxlan子网内广播arp请求,对应节点响应.group指定多播组的地址,group的值保持一致就可以,有一定范围要求</p>
  ...
  424  </div>
  425  </div><p>此时的网络拓扑</p>
  426: <img src="http://inksnw.asuscomm.com:3001/blog/vxlan使用_e3661f8f12dff2de75b4b064fa116bce.jpg" alt="vxlan docker" style="zoom:50%;" />
  427  <p>有了VXLAN接口的连接后，从vm1上docker容器发出的包到达docker网桥后，可以从网桥的VXLAN接口出去，从而报文在VETP(VXLAN接口)处被封装成VXLAN报文，再从物理网络上到达对端VETP所在的主机vm2。对端VTEP能正确解包VXLAN报文的话，随后即可将报文通过vm2上的docker网桥送到上层的docker容器中。</p>
  428  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/webhook影响k8s全局gc/index.html:
  268  </div>
  269  </div><p>查看kube-controller的日志会发现</p>
  270: <img src="http://inksnw.asuscomm.com:3001/blog/webhook影响k8s全局gc_7716fbb60d4999a9a203c277c9d34364.png" alt="image-20231121155432905" style="zoom:50%;" />
  271  <h2 id="原因追踪">原因追踪</h2>
  272  <p>逻辑在<code>pkg/controller/garbagecollector/garbagecollector.go</code> 183行</p>
  273  <p>gc会收集所有可删除的资源列表生成 <code>newResources</code></p>
  274: <img src="http://inksnw.asuscomm.com:3001/blog/webhook影响k8s全局gc_d3f59a700dbbb28410a9f431edd093a3.png" alt="image-20231121154832747" style="zoom:50%;" />
  275  <p>为所有可删除的资源创建informer</p>
  276: <img src="http://inksnw.asuscomm.com:3001/blog/webhook影响k8s全局gc_58e3285164444b1947f774b7d938d89f.png" alt="image-20231121155058272" style="zoom:50%;" />
  277  <p>核心原因就在这里</p>
  278: <img src="http://inksnw.asuscomm.com:3001/blog/webhook影响k8s全局gc_999ae8cda743b50757b01fe654de56a6.png" alt="image-20231121155142767" style="zoom:50%;" />
  279  <p>k8s要求所有可删除的资源的informer都同步完成才行, 而informer会调用list方法, 但是由于我们的crd使用的webhook还未安装/运行错误, 因此这个同步一直无法完成, 所以也影响到了其它资源的gc, 感觉这块的实现并不是很合理</p>
  280  <p>官方issue中也有提到这个, 但目前来看, 还未修复</p>

~/Desktop/blog/public/post/使用charles抓取k8s请求/index.html:
  165          <h2 id="配置代理">配置代理</h2>
  166  <p>安装<code>Charles</code>,查看设置<code>Proxy-&gt;Proxy Settings</code>,Charles默认监听于8888端口</p>
  167: <img src="http://inksnw.asuscomm.com:3001/blog/使用Charles抓取k8s请求_b8c69aac5fddbb8c2d0ecc23c47d32bf.png" alt="image-20230523172630419" style="zoom:50%;" />
  168  <h2 id="配置客户端证书">配置客户端证书</h2>
  169  <p>从kubeconfig中提取客户端的证书和私钥</p>
  ...
  187  </div>
  188  </div><p>配置Charles，<code>Proxy-&gt;SSL Proxying Settings</code>让他拦截端口为<code>6443</code>的流量：</p>
  189: <img src="http://inksnw.asuscomm.com:3001/blog/使用Charles抓取k8s请求_cc7636d20e3cb6e5130b86d2bc28f4c2.png" alt="image-20230523173343158" style="zoom:50%;" />
  190  <p>然后配置客户端私钥：</p>
  191: <img src="http://inksnw.asuscomm.com:3001/blog/使用Charles抓取k8s请求_950c76b038342426129a372040e59f01.png" alt="image-20230523171636777" style="zoom:50%;" />
  192  <h2 id="配置服务端证书">配置服务端证书</h2>
  193  <p>复制k8s集群主机<code>/etc/kubernetes/pki/</code>目录下的<code>apiserver.crt</code>与<code>apiserver.key</code></p>
  194  <p>配置</p>
  195: <img src="http://inksnw.asuscomm.com:3001/blog/使用Charles抓取k8s请求_742ae7fa188feb655d5b21b7489e05f9.png" alt="image-20230523171952403" style="zoom:50%;" />
  196  <h2 id="配置kubectl">配置kubectl</h2>
  197  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/使用github作为helm的chart仓库/index.html:
  264  </div>
  265  </div><h2 id="设置github-pages">设置GitHub Pages</h2>
  266: <img src="http://inksnw.asuscomm.com:3001/blog/使用github作为Helm的chart仓库_4702eb9bb1298308ea430cd67a2d0c70.png" alt="image-20220927172720598" style="zoom:50%;" />
  267  <blockquote>
  268  <p>设置<code>_config.yml</code>文件可以配置主题, 可选</p>

~/Desktop/blog/public/post/使用goland远程开发/index.html:
  208  <li>
  209  <p>把原本的<code>本地机器</code> 改过通过<code>管理目标</code>添加的远程主机,可以指定源码和二进制的目录
  210: <img src="http://inksnw.asuscomm.com:3001/blog/使用goland远程开发_2b21e985d3f722bd34ae811ca0368f1c.png" alt="image-20221113235729865" style="zoom:50%;" /></p>
  211  </li>
  212  <li>
  ...
  214  </li>
  215  </ul>
  216: <img src="http://inksnw.asuscomm.com:3001/blog/使用goland远程开发_69d0a34c9a4223cda14f14fee4582c7e.png" alt="image-20221113235449156" style="zoom:50%;" />
  217  <h2 id="验证">验证</h2>
  218  <p>此时点击<code>运行</code>或者<code>单步调试</code>都会在远程主机上运行, 远程主机目录中 <code>bin</code> 为我指定的二进制目录, <code>source</code> 为源码, <code>DPQVC5mPha</code> 为golang调试用的 <code>dlv</code>程序</p>

~/Desktop/blog/public/post/使用pyroscope追查资源占用/index.html:
  332  </div>
  333  </div><p>在界面上切换要监听的程序</p>
  334: <img src="http://inksnw.asuscomm.com:3001/blog/使用pyroscope追查资源占用_9395294a94cc66a18cef093a6a139588.png" alt="image-20230703180710548" style="zoom:50%;" />
  335  <h3 id="选项解释">选项解释</h3>
  336  <ul>
  ...
  350  <h2 id="cpu占用">cpu占用</h2>
  351  <p>可以看到<code>main.highCpu</code> 函数最占cpu</p>
  352: <img src="http://inksnw.asuscomm.com:3001/blog/使用pyroscope追查资源占用_dd9b2a28a44745ee0ffe77238e5d2800.png" alt="image-20230703181135182" style="zoom: 67%;" />
  353  <h2 id="内存占用">内存占用</h2>
  354  <p><code>main.highMem</code> 最占用内存</p>
  355: <img src="http://inksnw.asuscomm.com:3001/blog/使用pyroscope追查资源占用_4e1c8c1d85e5130a7958e50193fa9b4a.png" alt="image-20230703181252627" style="zoom: 67%;" />
  356  
  357      </div>

~/Desktop/blog/public/post/使用rust编写envoy扩展/index.html:
  294  </div>
  295  </div><p>envoy配置结构</p>
  296: <img src="http://inksnw.asuscomm.com:3001/blog/使用rust编写envoy扩展_1310473275110bfc967ed40c84d75284.png" alt="20200504160047" style="zoom: 50%;" />
  297  <p>启动访问 主机的<code>10000</code> 端口,发现请求被转发到了百度</p>
  298  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/升级带controller的crd/index.html:
  435  </div><p>因此, 只需要配置<code>served</code>字段即可暂停controller的运行,  但删除crd又涉及到cr的<code>finalizers</code> 问题,  需要手动清除, 原理可以参考 <a href="http://inksnw.asuscomm.com:3001/post/k8s%E5%88%A0%E9%99%A4crd%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/">k8s删除crd会发生什么</a></p>
  436  <h2 id="源码分析">源码分析</h2>
  437: <img src="http://inksnw.asuscomm.com:3001/blog/升级带controller的crd_9d09e21d90b2a27de40389b5034a2499.png" alt="image-20231211185944756" style="zoom:50%;" />
  438  <p>当<code>served</code> 为false时, 就会跳过写入<code>addAPIServiceToSync</code></p>
  439  <div class="highlight"><div class="chroma">
  ...
  470  </div>
  471  </div><p><code>addAPIServiceToSync</code> 会把数据写入到一个队列中, 这个队列会被取出注册api服务</p>
  472: <img src="http://inksnw.asuscomm.com:3001/blog/升级带controller的crd_75d369b81273b20a7e88b9e0c24170f4.png" alt="image-20231211190244071" style="zoom:50%;" />
  473  <p>如同这个字段的注释, api 服务关了, controller自然也就不运行了</p>
  474  <blockquote>

~/Desktop/blog/public/post/在k8s外部验证bearertoken/index.html:
  338  </div><p>JWT 通常由三个部分组成：header、payload 和 signature，它们由点 (.) 分隔。每个部分都是 base64Url 编码的 JSON 字符串。Header 包含 token 类型和加密算法，payload 包含一系列声明，signature 是对前两部分数据签名，用于验证数据的完整性。</p>
  339  <p>可以使用https://jwt.io/ 查看token信息</p>
  340: <img src="http://inksnw.asuscomm.com:3001/blog/在k8s外部验证bearertoken_1181bba4e34083cb460bdb2ca83f3edf.png" alt="image-20230713003203964" style="zoom:50%;" />
  341  <h2 id="使用token">使用token</h2>
  342  <p>再启动一个服务使用这个token验证</p>
  ...
  476  </div>
  477  </div><h2 id="访问测试">访问测试</h2>
  478: <img src="http://inksnw.asuscomm.com:3001/blog/在k8s外部验证bearertoken_8f74306191085e6a05e64be98e760823.png" alt="image-20230713000337476" style="zoom: 50%;" />
  479  
  480      </div>

~/Desktop/blog/public/post/容器技术原理-oci规范/index.html:
  351  </div>
  352  </div><p>解压查看,可以看到第二层只有一个app目录,与我们的<code>Dockerfile</code>配置一致</p>
  353: <img src="http://inksnw.asuscomm.com:3001/blog/容器技术原理-OCI规范_2eef73d14d6af274763c853300f0a7e1.png" alt="image-20221128213021570" style="zoom:50%;" />
  354  <h2 id="umoci制作镜像">umoci制作镜像</h2>
  355  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/本地签发证书代理https/index.html:
  449  </span></span></code></pre></td></tr></table>
  450  </div>
  451: </div><img src="http://inksnw.asuscomm.com:3001/blog/本地签发证书代理https_c2e63853f1d7b3601b4581e4fd824f59.png" alt="image-20240410103958436" style="zoom:50%;" />
  452  <p>此时,证书不受信任</p>
  453  <p>双击ca.crt加入到系统信任中</p>
  454: <img src="http://inksnw.asuscomm.com:3001/blog/本地签发证书代理https_79584d3e26dfab47d53144b237082679.png" alt="image-20240410104731767" style="zoom:50%;" />
  455  <p>再次访问</p>
  456: <img src="http://inksnw.asuscomm.com:3001/blog/本地签发证书代理https_879c2a3bf8d89a98fba411408abce9c5.png" alt="image-20240410104818353" style="zoom:50%;" />
  457  
  458      </div>

~/Desktop/blog/public/post/本地调试k8s/index.html:
  289  </span></span></code></pre></td></tr></table>
  290  </div>
  291: </div><img src="http://inksnw.asuscomm.com:3001/blog/本地调试k8s_2f27f1a6e2a99465d21b16f178efb7b7.png" alt="image-20230802163758775" style="zoom:50%;" />
  292  <p>kubectl配置</p>
  293  <p>在ubuntu主机上生成kubectl使用的config文件, 默认会生成到 <code>/etc/kubernetes/admin.conf</code> ,我们把它复制到<strong>mac</strong>和<strong>ubuntu主机</strong>的家目录</p>

~/Desktop/blog/public/post/查看容器重启前日志/index.html:
  461  </div><h2 id="源码分析">源码分析</h2>
  462  <p>当容器退出时, 会把容器id记录到status的<code>Terminated</code>字段中</p>
  463: <img src="http://inksnw.asuscomm.com:3001/blog/查看容器重启前日志_e6f01abc73d656bfd3c16c086c797391.png" alt="image-20231220225211656" style="zoom:50%;" />
  464  <p>查看当前pod状态, 看到上次退出的容器id 记录于<code>status.containerStatuses[0].lastState.terminated.containerID</code> 中</p>
  465  <div class="highlight"><div class="chroma">
  ...
  520  </div>
  521  </div><p>当加上<code>-p</code> 参数时, 查看日志时使用的容器id就会是上次的id</p>
  522: <img src="http://inksnw.asuscomm.com:3001/blog/查看容器重启前日志_7f695ed9b3f4f24bd0044323ad860ddb.png" alt="image-20231220225840595" style="zoom:50%;" />
  523  <p>接着就是通过容器id查看日志的标准流程了</p>
  524  <div class="highlight"><div class="chroma">

~/Desktop/blog/public/post/模拟k8s的watch/index.html:
  238  </div>
  239  </div><p>访问测试</p>
  240: <img src="http://inksnw.asuscomm.com:3001/blog/模拟k8s的watch_f8d0496aea5cb9e794d3e6d3f09fb9d7.png" alt="Snipaste_2023-06-21_23-00-29" style="zoom:50%;" />
  241  
  242      </div>

~/Desktop/blog/public/post/自定义日志库实现行号打印及跳转/index.html:
  225  </div>
  226  </div><p>可以看到终端上已经有了带超链接的行号, 点击可直接跳转</p>
  227: <img src="http://inksnw.asuscomm.com:3001/blog/自定义日志库实现行号打印及跳转_3c370988be6e601fc6cd627aba15e4d6.png" alt="image-20230814165916930" style="zoom:50%;" />
  228  <h3 id="klogv2">klog/v2</h3>
  229  <p>k8s使用的日志库 <code>k8s.io/klog/v2</code> 本身没有提供自定义Caller的功能, 改源码太黑科技了, 但开发的时候我们可以把它使用的日志库临时替换掉</p>
  ...
  255  </span></span></code></pre></td></tr></table>
  256  </div>
  257: </div><img src="http://inksnw.asuscomm.com:3001/blog/自定义日志库实现行号打印及跳转_8cce880b82d057990bfae8fe6e649fbd.png" alt="image-20240113224931657" style="zoom:50%;" />
  258  <p>可以看到已经显示了可跳转的超链接, 调试起来就方便了</p>
  259  <h2 id="后续">后续</h2>

~/Desktop/blog/public/post/通过kube-router学习网络/index.html:
  997  <h2 id="数据平面">数据平面</h2>
  998  <h3 id="pod到pod同主机">pod到pod(同主机)</h3>
  999: <img src="http://inksnw.asuscomm.com:3001/blog/通过kube-router学习网络1_52247654491a5c826a972cfff611648d.png" alt="image-20230728095909030" style="zoom:50%;" />
 1000  <p>创建两个同主机Pod</p>
 1001  <div class="highlight"><div class="chroma">
 ....
 1207  </div>
 1208  </div><h3 id="pod到outside">pod到outside</h3>
 1209: <img src="http://inksnw.asuscomm.com:3001/blog/通过kube-router学习网络1_e415d248c4d6991e7217ca5117c3b79a.png" alt="image-20230728105027087" style="zoom:50%;" />
 1210  <p><strong>查看iptables规则</strong></p>
 1211  <div class="highlight"><div class="chroma">
 ....
 1296  </div>
 1297  </div><h3 id="outside到svc到pod">outside到svc到pod</h3>
 1298: <img src="http://inksnw.asuscomm.com:3001/blog/通过kube-router学习网络1_6ca604634e8c6403b21587d64077648a.png" alt="image-20230728111722176" style="zoom:50%;" />
 1299  <p><strong>iptables策略</strong></p>
 1300  <div class="highlight"><div class="chroma">
 ....
 1316  </ol>
 1317  <h3 id="pod到svc到pod">pod到svc到pod</h3>
 1318: <img src="http://inksnw.asuscomm.com:3001/blog/通过kube-router学习网络1_34d789a9a265ed643f9579a7e32f514e.png" alt="image-20230728113136373" style="zoom: 50%;" />
 1319  <p>创建示例</p>
 1320  <div class="highlight"><div class="chroma">

150 matches across 78 files
